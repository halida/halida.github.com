
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>网络寻租</title>
  <meta name="author" content="机械唯物主义">

  
  <meta name="description" content="现代社会陷阱很多，一不小心就中招，很多陷阱你可能自己还没有意识到。 重点：你希望得到的，你相信的一切，都会有东西来骗你。 低级的是骗术： 希望得到教育，就会有垃圾学校，很贵很不值得的培训
希望得到健康，就会有养生课程，保健品，中医
希望得到财富，就会有传销，庞氏骗局，各类诈骗 中级的是做局： &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.linjunhalida.com/blog/page/5/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="网络寻租" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-26509244-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">网络寻租</a></h1>
  
    <h2>Programmer, Gamer, Hacker</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.linjunhalida.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">博客</a></li>
  <li><a href="/blog/categories/english">English Blog</a></li>
  <li><a href="/about">关于我</a></li>
  <li><a href="/blog/archives">存档</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/modern-pitfalls/">现代社会防骗指南</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-07-23T13:11:45+08:00" pubdate data-updated="true">Jul 23<span>rd</span>, 2017</time>
        
         | <a href="/blog/modern-pitfalls/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>现代社会陷阱很多，一不小心就中招，很多陷阱你可能自己还没有意识到。</p>

<p>重点：你希望得到的，你相信的一切，都会有东西来骗你。</p>

<p>低级的是骗术：</p>

<ul>
<li>希望得到教育，就会有垃圾学校，很贵很不值得的培训</li>
<li>希望得到健康，就会有养生课程，保健品，中医</li>
<li>希望得到财富，就会有传销，庞氏骗局，各类诈骗</li>
</ul>


<p>中级的是做局：</p>

<ul>
<li>化妆品：营造你可以变美的幻觉</li>
<li>钻石：针对爱情的吹捧</li>
<li>健身房：和你对赌你能够坚持下来</li>
<li>房地产：售楼部热闹的气氛让你失去判断力</li>
</ul>


<p>高级的是毒教育：</p>

<ul>
<li>公务员稳定：爸妈经验过时，以及希望你不要给他们添麻烦</li>
<li>民族主义，国家主义，大政府：政府从小进行的洗脑</li>
</ul>


<p>我们有什么办法来防止自己掉坑？几个办法：</p>

<ul>
<li>多看：收集事实。事实是检验理论的唯一标准。如果你发现结果不尽如人意，那么一定是哪里有问题。</li>
<li>多想：思考事物本质。</li>
<li>多听：以别人的角度来防止自己思维进入盲区</li>
<li>及时反应过来止损：没有绝对的方法防止自己掉坑的办法，但是一般都会形势明朗，之后赶紧跳出来，沉没成本不是成本。</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/understand-computer-science-in-one-day-fundamental/">一天弄懂计算机科学之体篇</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-07-16T13:30:16+08:00" pubdate data-updated="true">Jul 16<span>th</span>, 2017</time>
        
         | <a href="/blog/understand-computer-science-in-one-day-fundamental/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先就是计算机科学到底是什么？这个领域主要做的是什么事情？
计算机科学并不是关于如何让你熟悉理解操作计算机的，
计算机科学考虑的是：如何理解信息，记录信息，以及处理信息。</p>

<h3>如何理解信息</h3>

<p>信息是什么？信息是可能性的反面：确定性。
一件事情有可能发生，然后告诉你实际发生了，这就是信息。
比如我们知道明天有可能下雨，然后有一个神仙告诉你明天实际会不会下雨，这就是信息。</p>

<p>信息与信息之间是有度的区别的，告诉你明天是否下雨，以及一个人生日的信息量是不同的。
那么如何衡量信息的大小呢？可以用概率来看。概率越低，信息量越大。
比如明天是否下雨的概率是1/2，一个人生日的概率是1/365。</p>

<p>我们定义<a href="https://zh.wikipedia.org/zh-sg/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA">信息量</a>)：2^信息量=1/概率，下雨的信息量是1，生日的信息量是8.5左右。</p>

<h3>如何记录信息</h3>

<p>知道信息是什么了之后，我们可以考虑如何记录信息。
比如我们需要存储一个字符串，一个字符的信息量就是所有可能的字符，
比如简单的<a href="https://zh.wikipedia.org/zh-sg/ASCII">ASCII编码</a>，有255种均等可能的字符，信息量就是8。
我们可以以1-255之间的数字定义一个字符，比如A就是65。</p>

<p>然后我们去寻找可以存储信息的介质。
任何有状态的介质都可以存储信息，比如算盘，小石子放在格子里面之类。
我们可以根据状态的数量来判断一个介质能够存储多少信息量，
比如算盘一个5串的格子，有6种状态，可以存储的信息量就是2.5。
然后可以把字符串编码到这个介质上面，一个字符需要4个格子提供足够的信息量。</p>

<p>因为格子的信息量足够，我们可以有很多种方法把字符映射到算盘上面。
但是我们需要一种通用的方式来做这样的事情，这样我们可以很容易切换到其他介质上面去。
最好的方法是提供一种中间编码形式，字符编码转换成这个编码，然后这个编码转换到介质上。
我们用的是<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>，用这种0100这种方式表示。
因为一个字符只有两种状态，方便编码转换。</p>

<p>我们来看如何把一个字符转换到算盘上面。
A=65=01000001，二进制编码到算盘也很简单，
算盘的一格可以对应二进制的两位，算盘拨动1-4格4种状况就可以了。
当然有更省存储空间的算法，我们会在后续介绍。</p>

<p>我们可以寻找更便宜的存储介质，
现在用的是磁性介质（硬盘），二极管（内存，闪盘等），
一个1T磁盘可以存储1024<sup>4</sup>个字符，每个字符占用二进制的8位，一个磁盘就可以存储8T多的信息量。</p>

<h3>如何处理信息</h3>

<p>我们来到了最有趣的部分：如何处理信息。</p>

<p>我们需要理解处理信息的本质，然后再思考，如何创造一个机器来实现信息的处理。</p>

<p>比如我们需要把一张自拍照美化，其中的一个步骤就是把图片变白。
用信息化的处理方式,就是把每个点按照<a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F">RGB</a>的方式编码，
RGB代表三原色，每个原色用0-255表示亮度，000就是黑色，255-255-255就是白色。
我们把每个原色的权重加一个百分比，比如原先100就变成150，这样就实现了照片的美化处理。</p>

<p>也有一些简单的方法，比如打印照片，打光，重新拍一张，或者专门做一个处理照片的机器。
但是为什么要实现一台通用的处理信息的机器，来处理这个任务？</p>

<p>因为几个原因：</p>

<ul>
<li>这个机器有很大的潜能，一秒钟内就可以处理好这个照片</li>
<li>我们只需要对机器的指令做很简单的修改，就可以支持其他类似的工作</li>
<li>数据是信息化的，可以快速方便地无限分发</li>
</ul>


<p>而创造这样的通用计算机器是可以做到的，方法是把所有信息处理的动作分解，一直到可以通用的动作，然后再通过机器实现就可以了。</p>

<p>其中的一种通用的计算机模型如下：</p>

<ul>
<li>带有存储信息和指令的存储介质（指令本身也是信息）</li>
<li>带有一组快速存储介质（我们叫他们寄存器），可以与各类运算和处理单元交互</li>
<li>一个寄存器指向存储介质的一个地址，地址上带有让机器执行的指令，我们叫这个指令寄存器</li>
<li>机器根据指令寄存器指向存储介质地址的指令，控制各类运算和处理单元对寄存器上面的数据进行处理，包括这个指令寄存器本身！可以进行的操作包括：

<ul>
<li>数学运算：加减乘除，逻辑运算之类</li>
<li>状态查询：比如判断两个寄存器是否相等之类，保存结果到一个状态寄存器</li>
<li>条件判断：根据状态寄存器的结果进行特定的操作，比如指令寄存器地址加一</li>
<li>数据移动：把寄存器数据保存到存储介质，或者从存储介质读取数据到寄存器</li>
</ul>
</li>
</ul>


<p>比如上面的照片处理，可以用这个机器实现。机器的指令也保存在存储介质里面，具体如下：</p>

<ul>
<li>照片数据预先存放在存储介质上，按照RGB方式编码</li>
<li>操作指令也存放在存储介质上，机器的指令寄存器设置到这个地址，开机</li>
</ul>


<p>指令列表：</p>

<ul>
<li><code>起始</code>：读取照片数据地址到寄存器A</li>
<li>读取照片数据结尾地址到寄存器B</li>
<li><code>循环</code>：从照片数据地址读取一个点的数据到寄存器C</li>
<li>寄存器C加10%</li>
<li>寄存器A加一</li>
<li>判断寄存器A和B相等，如果相等跳过下一步指令</li>
<li>设置指令寄存器值为<code>循环</code>地址（下一步机器就会跳转到前面开始的地方）</li>
<li>设置指令寄存器值为<code>结尾</code>地址</li>
<li><code>结尾</code>：停机</li>
</ul>


<p>这些指令实际上的操作就是：转移数据，对数据进行运算，同时机器下一步执行的指令位置也是可以通过数据来操作的。
我们可以通过逻辑证明，带有这样功能的机器，可以把存储介质的状态，设置成任意我们想要的状态，从而证明这是一台可以进行通用信息处理的机器。</p>

<p>我们可以用各种方式来实现这样的通用计算机器，
比如机械齿轮，水力，算盘，甚至人工，但是最后我们会选择性能最好，价格最便宜的方案，现在就是用二极管，集成电路，
每秒可以进行几十亿次的运算。</p>

<p>以上内容就是信息科学的部分，我们知道信息的本质是什么，以及信息本身是以什么方式存在，然后是如何处理信息，
之后我们可以利用这些原理，创造出来计算机，以及配套的支持环境，来实现所有的信息存储，操作和处理。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/understand-computer-science-in-one-day/">一天弄懂计算机科学</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-07-16T13:13:04+08:00" pubdate data-updated="true">Jul 16<span>th</span>, 2017</time>
        
         | <a href="/blog/understand-computer-science-in-one-day/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>2016年底我去成都参加同学聚会，在火车上和一个大学生吹牛，说只要一天就可以教会他所有计算机科学&mdash;&mdash;的基础。
整理了一下，发现其实真的可以一天教会脉络，剩下的就是细化细节了。</p>

<p>我会用几篇文章来讲一下。我保证讲的一定是本质的东西。</p>

<p>所有计算机科学的领域，可以按照体，术，用三类来划分。</p>

<ul>
<li><a href="http://blog.linjunhalida.com/blog/understand-computer-science-in-one-day-fundamental">体</a>：包括如何理解信息，如何记录信息，以及最重要的：如何处理信息，都包含在信息科学里面。</li>
<li>术：包括如何利用信息科学的知识来创造一个可以处理信息的机器。

<ul>
<li>如何设计机器（计算机体系架构）</li>
<li>如何把程序语言转换成机器语言（计算机语言原理）</li>
<li>如何把机器管理起来（操作系统）</li>
</ul>
</li>
<li>用：

<ul>
<li>如何让机器跑得更快（算法）</li>
<li>如何存储和交换数据（数据库系统）</li>
<li>信息如何通讯（通讯协议，互联网）</li>
<li>还有其他细分的领域</li>
</ul>
</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/server-architecture-configuration-management/">如何一个人管理一堆服务器</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-07-08T19:45:17+08:00" pubdate data-updated="true">Jul 8<span>th</span>, 2017</time>
        
         | <a href="/blog/server-architecture-configuration-management/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>现在有一些服务器自动化配置工具，比如ansible，chef，puppet等，
利用它们，可以实现我的一个想法：用配置文件定义服务器架构，从而实现一个人管理好一堆服务器。</p>

<p>比如用ansible，我们可以用一个YAML文件申明一台服务器上面有什么：安装了什么应用，存在什么配置文件，跑了什么服务。
然后用命令行工具，比如ansible-playbook，就可以构建出来这样的服务器。</p>

<p>这样操作的优点：</p>

<ul>
<li>可视化：原先服务器手工构建，其他人，甚至构建者自己都会不清楚服务器的状况。现在有了配置文件，大家就可以知道服务器上面有什么，是如何配置的。</li>
<li>自动化：可以一条命令构建服务器，修改配置文件之后可以批量改动影响到的服务器，增加带有同样应用的服务器也非常简单，只要拷贝配置即可。如何搭建应用的知识可以复用。</li>
<li>版本控制架构变更：可以用git版本库管理服务器配置文件，我们可以记录每次服务器架构的变更了。</li>
</ul>


<p>具体操作：针对一组服务器架构，比如一个Rails应用以及附属的各个服务器，
可以创建一个git版本库记录所有的ansible playbook，
然后把敏感的配置文件，放到另外一个私密git版本库里面，
<a href="http://blog.linjunhalida.com/blog/encrypted-git-repo/">加密存储</a>，保障安全性。</p>

<p>我搭建了一个演示用例，包括：</p>

<ul>
<li><a href="https://github.com/halida/haterslist">一个Rails应用</a></li>
<li><a href="https://github.com/halida/haterslist_ansible">ansible配置</a></li>
<li><a href="https://github.com/halida/haterslist_conf">私密配置</a>（仅限于演示）</li>
</ul>


<p>里面包含几台服务器：</p>

<ul>
<li><a href="https://github.com/halida/haterslist_ansible/blob/master/playbooks/app.yml">app.yml</a>
搭建Rails服务器，包括mysql数据库，nginx，systemd自动启动和监控脚本。</li>
<li><a href="https://github.com/halida/haterslist_ansible/blob/master/playbooks/backup.yml">backup.yml</a>
自动备份mysql数据库</li>
<li><a href="https://github.com/halida/haterslist_ansible/blob/master/playbooks/zabbix.yml">zabbix.yml</a>
对应的监控服务器（未完工）</li>
</ul>


<p>私密配置版本库里面存放了所有的配置文件，构建一些应用需要的用户名和密码，一些初始化数据等。
在playbook里面会去读取这些配置文件，或者拷贝这些文件到服务器上面去。</p>

<p>管理Rails应用还需要一些其他的功能，限于时间，我就没有实现了，包括：</p>

<ul>
<li>jenkins 自动化测试</li>
<li>sandbox，staging环境</li>
<li>mysql多主从架构</li>
<li>多app负载均衡</li>
</ul>


<p>综上所述，一个复杂的多服务器应用架构，可以用上面的几个版本库定义出来，并且可以根据需要动态进行修改。
这种配置方式适用于几十台机器之内的半静态架构，并且可以多人同时管理。</p>

<p>更进一步，如果利用aws或者digitalocean的api，服务器创建也可以采用配置文件定义。
不过我觉得使用起来并不是很方便，就没有这样做了。</p>

<p>如果机器数量多，或者需要动态伸缩，配置文件可能就不太适合了，可以用ansible-tower这种在线配置管理工具。
不过我觉得大多数的公司都不会达到这样的级别，因此配置文件就够用了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/retire-some-programming-languages/">我们需要淘汰一些编程语言</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-07-03T11:24:09+08:00" pubdate data-updated="true">Jul 3<span>rd</span>, 2017</time>
        
         | <a href="/blog/retire-some-programming-languages/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在IT领域，因为从业者素质参差不齐的原因，很多垃圾东西在流传，其中危害最大的一类就是垃圾编程语言。
包括但是不限于：bash，perl，javascript，php，python。</p>

<h2>这些语言为什么烂</h2>

<p>他们的设计者并没有受到很好的编程语言设计教育，或者没有足够的时间进行设计，
造成的结果是，这些编程语言的设计存在很多问题。比如语法设计有问题，在语法处理上存在设计错误，写法晦涩不容易弄懂影响阅读，
缺少很多保证程序安全的设计，带有性能问题，语言本身缺少很多核心功能等。
具体内容可以去看<a href="http://www.yinwang.org/">王垠的博客</a>。</p>

<p>我稍微列一下烂在哪里：</p>

<ul>
<li>bash: 缺少大量的编程语言抽象特性，语法是程序员乱设计的，接口是基于字符串而不是定义明确的数据结构</li>
<li>perl: 语法也是程序员乱设计的，难以阅读</li>
<li>php：乱语法，现在改进了很多，但是为了兼容还是带有一堆历史问题</li>
<li>javascript：几十天做出来的一个没有完善好的类lisp语言，早就应该被淘汰掉，因为web流行危害严重</li>
<li>python：比上述语言好一些，但是也有一堆设计缺陷，比如用缩进替代定义明确的语法块，匿名函数实现烂等</li>
</ul>


<h2>烂语言的害处</h2>

<p>编程语言是程序的组成部分，类似于房屋的原材料。一旦你选择了编程语言，以后再要替换只能全部重写。
软件后续的维护和拓展都只能基于这种语言，会延续到软件的整个生命周期。
引入了一个烂语言，他的危害会覆盖软件的整个生命周期，并且像癌症一样，随着软件的传播而蔓延，
进而伤害其他依赖这个软件的系统，同时也给这个烂语言打了广告。</p>

<h2>如何处理</h2>

<p>对于旧的用了烂语言的项目，尽量以维护为主，不要增加新功能延长它们的生命周期。
比如systemd替代了旧的init系统，就淘汰掉很多垃圾bash脚本。</p>

<p>新的项目尽量不要用这些烂语言，可以寻找一些替代品。很多语言经过了良好的设计，值得推荐，比如java，csharp。
脚本语言和Linux下系统语言我还没有找到好的选择。我现在用Ruby但是Ruby也有很多问题，不值得长期使用。
Linux下系统语言可能有Rust，D，我不确定是否足够好，但是可以尝试。
Javascript可以用高层语言替代比如TypeScript，Webassembly推广之后会有很多好语言可以使用。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/encrypted-git-repo/">加密git远端版本库</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-06-08T10:39:36+08:00" pubdate data-updated="true">Jun 8<span>th</span>, 2017</time>
        
         | <a href="/blog/encrypted-git-repo/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我打算把所有服务器的配置文件用git管理起来，这样可以记录配置变更状况。
但是有一个问题是，如何多人协作？服务器配置信息非常敏感，如果这个版本库泄漏，整个公司的服务器架构就彻底泄漏了。
这个版本库只能在开发者本地电脑里面解密，远程托管版本库的服务器不应该知道文件里面的内容。</p>

<p>那么解决办法就是：本地git版本库是解密的，在上传过程中内容全部加密，密钥保存在本地，同时密钥可以分享给其他开发者。</p>

<p>考虑了几个解决方案：</p>

<p><a href="https://github.com/AGWA/git-crypt">git-crypt</a>：可以加密部分文件，原理是加上了加密的fiter和diff，
但是官方说只适合加密部分文件，而不适合全版本库加密。部分文件加密很容易造成信息泄漏，一定要全版本库加密才适合。</p>

<p>串联sshfs和远程服务器加密文件系统encfs：首先用sshfs加载远端文件系统，然后用encfs创建加密文件系统。
我估计无法解决多人同时push情况下的竞争条件，并且encfs有安全漏洞，使用上push/pull之前需要加载两层文件系统，不是很方便。</p>

<p><a href="https://github.com/spwhitton/git-remote-gcrypt">git-remote-gcrypt</a>用gpg进行远端加密。
比较符合我预期的模式，但是用gpg不是特别方便协作。但是别的方法走不通，只有这个方法可用。</p>

<h2>使用方法</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span></span><span class="c1"># 安装git-remote-gcrypt和gnupg</span>
</span><span class='line'>sudo apt-get install git-remote-gcrypt gnupg
</span><span class='line'>
</span><span class='line'><span class="c1"># 创建一个gpg的key，需要设置用户名，邮箱，描述等，不要设置过期时间</span>
</span><span class='line'>gpg --gen-key
</span><span class='line'>
</span><span class='line'><span class="c1"># 记录一下生成的key的ID，比如2048R/A0F0B575里面的A0F0B575，2048代表加密轮数，越多越不容易破解</span>
</span><span class='line'>gpg --list-keys
</span><span class='line'>
</span><span class='line'><span class="c1"># 生成一个测试版本库</span>
</span><span class='line'>mkdir test1 <span class="o">&amp;&amp;</span> <span class="nb">cd</span> test1
</span><span class='line'>git init .
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;test&quot;</span> &gt; a.txt
</span><span class='line'>git add . <span class="o">&amp;&amp;</span> git ci -m <span class="s2">&quot;update&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 在你的github上面创建一个project，比如：https://github.com/halida/ttt</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 配置远端加密版本库</span>
</span><span class='line'>git remote add cryptremote gcrypt::git@github.com:halida/ttt.git
</span><span class='line'><span class="c1"># 最好指定用哪个key加密，这样可以共享这个key给其他人用</span>
</span><span class='line'>git config remote.cryptremote.gcrypt-participants <span class="s2">&quot;A0F0B575&quot;</span>
</span><span class='line'><span class="c1"># push到远端</span>
</span><span class='line'>git push cryptremote master
</span><span class='line'><span class="c1"># 访问远端版本库，看看文件内容，和commit里面的信息，是不是都是加密的？</span>
</span></code></pre></td></tr></table></div></figure>


<p>如何分享给其他人</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span></span><span class="c1"># 导出key</span>
</span><span class='line'>gpg --export-secret-key -a <span class="s2">&quot;share@share.com&quot;</span> &gt; secretkey.asc
</span><span class='line'><span class="c1"># 把secretkey.asc分享给其他人，拷贝的时候记得先压缩加密一下再发送，更安全</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 别人电脑里面导入</span>
</span><span class='line'>gpg --import secretkey.asc
</span><span class='line'><span class="c1"># 下载代码</span>
</span><span class='line'>git clone gcrypt::git@github.com:halida/ttt.git test2
</span><span class='line'><span class="c1"># 也要指定一下用什么key加密</span>
</span><span class='line'>git config remote.cryptremote.gcrypt-participants <span class="s2">&quot;A0F0B575&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>用这种方法，可以用git管理一些私密又需要协作的信息（比如服务器配置），
也可以把github当作私密的版本控制系统来用（commit的消息还是明文的）。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/password-authentication-is-bad/">比密码登录更好的权限验证方式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-05-15T13:37:59+08:00" pubdate data-updated="true">May 15<span>th</span>, 2017</time>
        
         | <a href="/blog/password-authentication-is-bad/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>现在各个网站，工具都采用密码方式登录，我觉得很不方便，同时安全性也不能得到保障，
这里我提出一种更安全更易用的权限验证方式，彻底解决这些问题。</p>

<p>首先我们看密码验证的缺点，从易用性和安全性来考虑。</p>

<p>密码的长度取决于人类记忆力。如果是随机密码，人类很难记住，最长大概8位，而现在云计算情况下，10位以下暴力破解并不是很困难的事情。
如果是非随机密码（比如一句话），单词的概率空间也和随机密码差不多甚至更少。
为了获得更可靠的安全性，密码必须设置得更长一些，对人的负担更重。
随着现在计算力的增长，为了安全，密码必须越设越长，而人的记忆能力是很难增长的。</p>

<p>从使用方式上，密码会传播到远端平台，在本地/网络/远端任何一个节点被监听到，用户的密码和信息就会被泄漏掉。</p>

<p>对于不同的网站或者应用，应该采用不同的密码，不然一个网站的信息泄漏了，就会影响到其他网站的安全性。
但是对于普通人而言，记忆超过3个复杂密码是很困难的。这也是为什么普通人往往通用一个常用密码，
然后现在各大网站很多的用户密码信息是泄漏的，对于普通人而言，常用密码已经被泄漏出去了。</p>

<p>现在有第三方的密码记录工具，比如lastpass，但是它增加了单点失效的风险：如果lastpass被攻克了，用户的所有密码都会被泄漏。</p>

<p>综上所述，密码验证方式缺陷很多，并不能很好地保障易用性和安全性。</p>

<p>从原理上面思考，借鉴现成的一些安全领域经验，我觉得更好的验证方式如下：</p>

<p>采用RSA方式生成公钥和私钥，私钥保存在一个绝对安全的单独硬件设备上，只提供解密服务。比如做成一个芯片，挂在脖子上或者植入皮下组织。
本地电脑能够访问该设备。</p>

<p>网站登录和验证过程采用和SSH协议一样的方式，基本上就是用户提供公钥给网站，网站通过公钥加密共享密钥过来，建立安全通讯频道。</p>

<p>这种方式的好处：</p>

<ul>
<li>易用性：用户只要输入网站，在本地电脑上面刷一下芯片就可以登录了，无须繁琐的密码输入。</li>
<li>秘密信息（私钥）保证安全，第三方除了偷窃芯片设备，没有任何办法获得私钥。</li>
<li>本地/网络/远端通讯模型中，网络没有办法窃听通讯。就算在本地或者远端设置了木马窃听信息，也不会丢失私钥。</li>
<li>一个网站被攻破，只代表这个网站的用户数据泄漏了，不影响该用户其他网站的安全性。</li>
</ul>


<p>一些我还没有想明白的问题：</p>

<ul>
<li>如何保证密钥设备被电脑读取的时候不开放给不相关的网站？这样当本地电脑中了木马的时候，也不会泄漏远端网站的信息？</li>
<li>密钥设备丢失了怎么办？可以在家里备份保存一个。如果真的全部丢失了，只有一个个通知网站更换该用户的公钥，更换协议需要思考如何保证安全同时又能够做到替换。</li>
</ul>


<p>难点：</p>

<ul>
<li>因为涉及到硬件，比较难部署开，需要用户购买一个安全芯片，以及读取和烧录设备。</li>
<li>需要改变用户习惯，随身携带一个安全芯片。</li>
<li>需要各大网站支持这种登录方式。</li>
</ul>


<p>我觉得可能布开的方式是这样：首先要有一个大公司推动（比如苹果或者谷歌），在一个销量很大的设备上（比如手机），
这个芯片也还是要做到设备独立，不能做到手机里面。后面要有一个所有大公司参与的标准化组织制定规则。
感觉难度挺大的。不过这是更安全的做法，以后应该路径到达这种方式。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/motobike/">考虑摩托车</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-04-16T19:26:06+08:00" pubdate data-updated="true">Apr 16<span>th</span>, 2017</time>
        
         | <a href="/blog/motobike/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>现在我用的小电驴很好用, 是<a href="http://www.qqddc.com/html/zt/moka.html">爱玛摩卡</a>, 现在已经停产了, 长得这样:</p>

<p><img src="http://i.imgur.com/LEVW2YA.jpg" alt="image" /></p>

<p>它的好处是:</p>

<ul>
<li>非超标, 不需要上牌.</li>
<li>可以载两个人, 后面的座位高度适合成人, 有靠背很安全.</li>
<li>足够小, 可以上小型电梯, 城里面开起来非常顺畅.</li>
<li>踏板上面可以放下很大的东西, 适合运货.</li>
</ul>


<p>但是也有以下问题:</p>

<ul>
<li>速度最高30, 不够快.</li>
<li>续航不行, 没法出城.</li>
<li>轮子小通过性不好.</li>
<li>没有左右转向灯, 速度表等实用安全配置.</li>
</ul>


<p>解决办法有两个: 短途还是小电驴, 出城就靠汽车+折叠自行车. 或者买一个摩托车.</p>

<p>我考虑摩托车的方案. 摩托车使用上面相对电动车来说会更复杂一些, 毕竟是机械机构. 但是动力, 续航, 安全都比电动车好太多.</p>

<p>摩托车和汽车类似, 质量好的一般是合资日企, 比如本田. 所以我尽量还是在合资品牌里面选, 少折腾.</p>

<p>摩托车的样式主要有跨骑,弯梁和踏板. 区别在<a href="https://www.zhihu.com/question/52607019/answer/131316979">这里</a>,
主要就是跨骑速度快续航高, 但是低速不好开, 运不了货. 踏板相对容易坏, 轮子小通过性差, 弯梁不容易坏.</p>

<p>所以首先我看弯梁. 但是看了本田, 雅马哈, 铃木, 他们的弯梁车都挺丑的, 去店里面看实物也很丑, 实在下不去手.
看了一圈, 国内的摩托车丑的居多, 类似小电驴, 也没有什么美观的型号.
稍微好看一些的只有跨骑了. 但是各大跨骑车都挺大的, 也不方便运货, 生活上不是很方便, 并且我也不需要开太快的车.</p>

<p><img src="https://pic4.zhimg.com/v2-b022285c1e5561444c5ec37404726feb_b.jpg" alt="image" /></p>

<p>后面发现还有小的跨骑车, 比如<a href="http://ptmx5.pixnet.net/blog/post/189348267-%E9%87%8D%E8%BB%8A%E6%97%A5%E8%AA%8C28%EF%BC%9A%E8%BF%B7%E4%BA%BA%E5%B0%8F%E5%8F%AF%E6%84%9B-honda-msx125%E5%85%A5%E6%89%8B%E5%88%86%E4%BA%AB">本田 MSX125</a>,
国内很多仿制的, 但是我还是信不过质量.</p>

<p>还有踏板, 本田的<a href="http://post.smzdm.com/p/335810/">自由Today</a>挺不错的, 但是我不太想要踏板车了, 和电驴区别不大.</p>

<p><img src="http://am.zdmimg.com/201508/31/55e3afb6301f1.jpg_e600.jpg" alt="image" /></p>

<p>选来选去, 最后发现还是现在的摩卡适合我的需求, 摩托车还是算了.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/new-bag/">如何挑选背包</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-04-16T18:21:19+08:00" pubdate data-updated="true">Apr 16<span>th</span>, 2017</time>
        
         | <a href="/blog/new-bag/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前买的一个米黄色电脑背包已经用了很久, 一直被老婆吐槽太丑,
于是花了一些时间研究了一下买什么背包比较好.</p>

<p>首先看我的实际需求. 我现在在家工作, 虽然不需要通勤, 但是还是会会骑小电驴出门透气换地方工作,
偶尔出去短途旅行一下. 所以一个可以装电脑, 一周内换洗衣物的背包还是需要的.
老婆发过来的一些潮牌包包看起来不错, 但是一个耐用好用低调的包更适合我的想法.</p>

<p>首先看看市场上有什么可以选择的. 我去看<a href="http://search.smzdm.com/?c=post&amp;s=%E8%83%8C%E5%8C%85">什么值得买的原创评测</a>,
Google搜索backpack, 了解到了一些知名的背包品牌:
一部分是主流户外运动用品品牌, 一部分是数码背包品牌.
好的背包价格也不便宜.</p>

<p>为了能够更了解产品, 我在Youtube上面搜索大家经常提到的背包型号, 看看评测,
慢慢对于自己理想中的背包有了概念了.</p>

<p>首先细化我的需求:
可以带15寸笔记本, 方便长时间背着, 可以携带短途旅行的东西, 耐用, 美观, 可以背在前面防小偷.</p>

<p>研究出来的方案:
中等体积大小(22L-30L), 简易背负(无背负不舒服, 复杂背负太大太重), 独立电脑仓位(保护更有力),
足够体积的主仓位(放衣物以及以后运输的杂物), 带有侧袋可以放水杯.
颜色我更偏好黑色, 看起来更&#8221;商务&#8221;一些, 不浮夸.</p>

<p>考虑了这些品牌: Osprey, Incase, Gregory, Arcteryx, Colehaan, Wenger,
根据我的需求, 筛选了这些型号:</p>

<p><a href="https://www.ospreypacks.com/kr/en/product/pixel-PIXEL.html">Osprey pixel</a>, <a href="http://post.smzdm.com/p/311426/">Incase EO Travel</a>, <a href="http://post.smzdm.com/p/532225/">Gregory SKETCH 22L</a>.</p>

<p>然后就等合适的打折出来, 就可以买了.</p>

<p>不过我新买的笔记本到货, 急用包, 同时也看到亚马逊上面有7折优惠, 上去搜索了一下,
本来可以考虑<a href="https://www.amazon.cn/%E8%BF%90%E5%8A%A8-%E6%88%B7%E5%A4%96-%E4%BC%91%E9%97%B2/dp/B015SBJU4W/ref=sr_1_1?ie=UTF8&amp;qid=1492339703&amp;sr=8-1&amp;keywords=Gregory%2BSKETCH%2B22&amp;th=1">Gregory SKETCH 22</a>,
但是剩下的几个颜色不好看.
偶然翻到之前看到过的<a href="http://post.smzdm.com/p/498384/">Osprey Momentum 26L</a>, 感觉还可以, 就下单买了, 总价524还算可以吧.</p>

<p>两天就到货了, 兴奋地研究了各种配置, 包的做工比我旧包好多了, 感觉很硬实.</p>

<p><img src="http://i.imgur.com/lrutv4N.jpg" alt="image" /></p>

<p>这是上身效果.</p>

<p><img src="http://i.imgur.com/ueom1Ka.jpg" alt="image" /></p>

<p><img src="http://i.imgur.com/1B5r6ZG.jpg" alt="image" /></p>

<p>背上去舒适度算一般, 天热背还是会闷, 还算满足需求吧.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/gns3/">GNS3介绍,安装和使用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-04-15T20:01:27+08:00" pubdate data-updated="true">Apr 15<span>th</span>, 2017</time>
        
         | <a href="/blog/gns3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://www.gns3.com/">GNS3</a>是一个虚拟网络的工具,用它可以学习如何配置局域网,以及在实际进行物理配置之前测试是否工作正常.</p>

<p>我为什么要研究这个工具呢? 因为现在我的家用网络有一些需求需要进行复杂的路由配置, 实际配置出现问题很浪费时间,
不如用一个虚拟工具来测试研究. 如果你对如何搭建局域网或者有类似建网需求, 可以考虑用这个工具.</p>

<p>文档<a href="https://docs.gns3.com/">在这里</a>, 我就不重复写怎么安装了.
在安装之前, 我先讲一下原理, 知道了原理, 后面过程会顺利很多.</p>

<h1>原理</h1>

<p>GNS3的底层是<a href="https://en.wikipedia.org/wiki/Dynamips">Dynamips</a>, 一个虚拟Cisco路由器的模拟器.
GNS3同时它也支持其他的虚拟系统, 比如Vmware, Qemu, Virtualbox, docker等, 用这些虚拟化工具来模拟路由和主机.</p>

<p>Dynamips是基于Linux的, 所以在Windows和MacOS下面,
为了能够正常使用, 需要安装一个GNS的虚拟机(里面安装的是Ubuntu),
因为它里面需要跑虚拟化(虚拟路由设备或者主机), 所以会出现嵌套虚拟,
推荐使用Vmware来安装, 用VirtualBox性能会比较差.
如果你是Linux系统, 建议直接用GNS Server.</p>

<p>GNS Server是GNS的后端, 一个python写的管理系统, 它会根据前端的配置, 创建对应的虚拟化系统,
比如你创建了2个主机(VPCS), 一个路由(比如用Qemu虚拟的RouteOS),
它会创建两个VPCS进程, 用Dynamips虚拟化一个路由, 把他们连接起来.</p>

<p>实际执行的命令如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># qemu RouteOS
</span><span class='line'>/usr/bin/qemu-system-x86_64 -name RouteOS-1 -m 128M -smp cpus=1 -enable-kvm -machine smm=off -boot order=c \
</span><span class='line'>  -drive file=/home/halida/GNS3/projects/routeos_simple/project-files/qemu/f280f531-91cd-4290-a61b-98d3299a2bb7/hda_disk.qcow2,if=ide,index=0,media=disk \
</span><span class='line'>  -serial telnet:127.0.0.1:5000,server,nowait \
</span><span class='line'>  -monitor tcp:127.0.0.1:54263,server,nowait \
</span><span class='line'>  -net none -device e1000,mac=00:8f:b6:2b:b7:00,netdev=gns3-0 \
</span><span class='line'>  -netdev socket,id=gns3-0,udp=127.0.0.1:10002,localaddr=127.0.0.1:10001 \
</span><span class='line'>  -device e1000,mac=00:8f:b6:2b:b7:01,netdev=gns3-1 \
</span><span class='line'>  -netdev socket,id=gns3-1,udp=127.0.0.1:10003,localaddr=127.0.0.1:10000 \
</span><span class='line'>  -device e1000,mac=00:8f:b6:2b:b7:02 \
</span><span class='line'>  -device e1000,mac=00:8f:b6:2b:b7:03 \
</span><span class='line'>  -nographic
</span><span class='line'>
</span><span class='line'># vpc
</span><span class='line'>/usr/bin/vpcs -p 5001 -m 0 -i 1 -F -R -s 10002 -c 10001 -t 127.0.0.1 startup.vpc</span></code></pre></td></tr></table></div></figure>


<p>参数里面会做几件事情: 创建虚拟的网口, 绑定在本地机器的特定端口上面, 然后各个进程会通过这些端口来进行通讯.
同时也会把管理端口用telnet暴露出来, 方便前端用Console命令连上去配置.</p>

<h2>安装过程</h2>

<p>因为GNS的工具链主要在Linux, 我倾向于用Linux来装这样的测试环境. 所以里面推荐的GNS VM我就没有去装了.</p>

<p>安装完毕之后, GNS是不自带路由器的镜像的, 它提供一些简单的虚拟设备,
比如VPCS, 它其实就是一个单独的进程, 模拟一个主机设备, 带有设置IP, Ping等简易网络工具.
你需要自己导入路由的设备.</p>

<p>如果你是要模拟Cisco的设备, 可以在<a href="http://protechgurus.com/download-gns3-ios-images/">这里下载</a>,
我是用来测试RouteOS的环境的, 直接在<a href="https://mikrotik.com/download">官方网站</a>下载ISO镜像, 本地用Qemu安装.</p>

<p>选择虚拟系统: 如果是Cisco的路由器, 没得说, 只能用Dynamips, Dynamips一定要设置Idle-PC, 减少CPU性能消耗.
如果是其他基于Linux的路由系统, 在Linux下面, 我觉得Qemu比VirtualBox和VMWare都好用, 它性能更好一些.
当然用Docker这种内核共用虚拟性能会更好, 不过我没有尝试.</p>

<p>GNS下安装RouteOS, 首先要去官方下载ISO镜像文件, 然后执行命令行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 创建镜像文件
</span><span class='line'>/usr/local/bin/qemu-img create -f qcow2 routeros-6.15.img 200M
</span><span class='line'># 跑虚拟机, 安装系统
</span><span class='line'>/usr/local/bin/qemu-system-i386 -m 512 -enable-kvm -boot d -cdrom mikrotik-6.15.iso routeros-6.15.img</span></code></pre></td></tr></table></div></figure>


<p>安装好之后, 就可以用GNS导入这个镜像, 进行使用了. 官方下载的ISO, 可以免费使用一天, 用来测试问题不大.</p>

<h2>模拟实验</h2>

<p>我做了两个模拟实验, 用来学习GNS的使用.</p>

<p>第一个是简单的RouteOS连接两个主机, DHCP分配IP地址.</p>

<p><img src="http://i.imgur.com/bmtDUDc.png" alt="image" /></p>

<p>用Console连上RouteOS-1, 进行这样的配置:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 创建一个bridge, 把端口都连接起来
</span><span class='line'>/interface bridge add
</span><span class='line'>/interface bridge port add interface=ether1 bridge=bridge1
</span><span class='line'>/interface bridge port add interface=ether2 bridge=bridge1
</span><span class='line'># 创建 dhcp, 给大家分配IP地址
</span><span class='line'>/ip address add address=192.168.10.1/24 network=192.168.10.0 interface=bridge1
</span><span class='line'>/ip pool add name=dhcp-pool ranges=192.168.10.10-192.168.10.254
</span><span class='line'>/ip dhcp add name=dhcp-main interface=bridge1 address-pool=dhcp-pool
</span><span class='line'>/ip dhcp network add address=192.168.10.0/24 gateway=192.168.10.1 netmask=24
</span><span class='line'>/ip dhcp enable 0</span></code></pre></td></tr></table></div></figure>


<p>然后就可以进到两台机器的Console里面, 执行<code>ip dhcp</code>自动获取IP地址, 用<code>ping</code>去看是否可以连接到另外一台机器.</p>

<p>第二个是简单的多路由通讯方案:</p>

<p><img src="http://i.imgur.com/GEDQVOf.png" alt="image" /></p>

<p>三个路由分别管理一个网段, 然后每个网段都可以通过路由的设置, 联系到其他网段里面的机器.</p>

<p>这里只列出来RouteOS-1的配置, DHCP部分和上面重复, 就不写了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 设置连接到其他路由器端口的IP
</span><span class='line'>/ip address add address=172.16.10.1/30 network=172.16.10.0 interface=ether1
</span><span class='line'>/ip address add address=172.16.12.1/30 network=172.16.12.0 interface=ether2
</span><span class='line'># 增加路由, 对方网段从哪里走
</span><span class='line'>/ip route add dst-address=192.168.20.0/24 gateway=172.16.10.2
</span><span class='line'>/ip route add dst-address=192.168.30.0/24 gateway=172.16.12.2</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/6/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/4/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/radio-useless/">收音机没啥用了</a>
      </li>
    
      <li class="post">
        <a href="/blog/ipkvm/">低成本IPKVM控制多台主机</a>
      </li>
    
      <li class="post">
        <a href="/blog/bed-car/">床车方案</a>
      </li>
    
      <li class="post">
        <a href="/blog/car-air-conditioner/">床车空调方案</a>
      </li>
    
      <li class="post">
        <a href="/blog/work-in-car/">车作为第二空间</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/halida">@halida</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'halida',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2024 - 机械唯物主义 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>


</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'halidasvps';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
